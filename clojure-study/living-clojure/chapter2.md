# 제어문과 함수형 반환

## 용어 정리

* 구조 분해(destructuring)
  * 컬렉션의 요소 중에 관심의 대상인 요소를 뽑아내어 이름을 부여하는 방법
* 지연 평가(lazy evaluation)
  * 재귀(recursion)

#### 식(expression), 형식(forms)

* 식 : 평가될 수 있는 코드
* 형식 : 평가될 수 있는 적법한 식
  * 문법에 맞지 않으면 형식이 아니다.


## 흐름 제어(Control flow)


### 기본적인 논리 검사

* `class`라는 함수를 통해, 평가된 값이 어떤 클래스에 속하는지 확인할 수 있다.
  * 예시 : `(class true) ;=> java.lang.Boolean`
* 함수의 값이 불리언 값을 경우, 함수의 이름 맨 끝에 물음표를 붙이는 것이 관례이다. (ruby와 비슷함)
  * 예시 : `(true? true) ;=> true`, `(false? false) ;=> true`
  * 값이 없는지 확인할 때는 `nil?` 함수를 이용할 수 있다.

#### 논리 검사 목적으로 쓰이는 함수 정리
  * `(true? a)` : 참인지 검사한다.
  * `(false? a)` : 거짓인지 검사한다.
  * `(nil? a)` : 값이 없는지 검사한다.
  * `(= a b)` : 동등임을 검사한다.
    * `(not= a b)` : `(not (= a b))` 의 축약형, 동등이 아님을 검사한다.

### 컬렉션에 사용하는 논리 검사

#### 컬렉션 추상 / 시퀀스 추상
* 컬렉션은 벡터, 리스트, 맵 처럼 단순히 요소를 모아놓은 것.
  * 컬렉션은 `clojure.lang.IPersistentCollection`(컬렉션 추상) 인터페이스를 구현한 존속적, 불변적인 자료구조이다.
  * 이를 통해 컬렉션들은 `count`, `conj`, `seq` 같은 함수들을 공유한다.
* `seq` 함수는 컬렉션을 받아서 시퀀스로 바꾸어주며, 빈 컬렉션이면 `nil`을 반환한다.
  * 시퀀스는 시퀀스 추상을 구현한 것이다.
  * 시퀀스 추상은 컬렉션을 리스트처럼 순차적으로 다룰 수 있게 해준다.
  * 시퀀스는 존속적이고 불변이며 `first`, `rest`, `cons` 함수를 구현한다.
* 실제로, 컬렉션을 처리하는 많은 함수들이 내부적으로 `seq` 함수를 사용하고 있다.
  * 예를 들어, `first`를 벡터에 대해서 적용할 경우, 벡터를 시퀀스로 바꿔주어야 하는데, 이 때, 내부적으로 사용자 대신 `seq` 함수를 사용한다.

#### 컬렉션에 논리 검사를 적용하기 위해 쓰이는 함수 정리

* `(empty? a)` : 컬렉션이 비어있는지 확인
  * 실제 정의 : `(defn empty? [col] (not (seq coll)))`
* 