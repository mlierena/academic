# 클로저의 구조

* 클로저 코드는 일반적으로 리스프와 같은 문법을 가진다.
  * `(operator operand1 operand2)`
    * 연산자 및 함수가 앞에 오고, 피연산자가 뒤에 오는 구조의 문법이다.

## 리터럴(literal)

* 일반적인 프로그래밍언어처럼 `실수형`, `정수형`, `문자열`, `문자`, `리스트`, `불리언` 자료형을 제공하며, 이를 리터럴 값으로 활용할 수 있다.
  * 리터럴 값들은 repl에 입력했을때 자기자신으로 평가된다. 
* `분수` 형태의 자료형도 제공한다.
  * 1/3 과 같은 분수가 평가될 때 실수로 변환되지 않아, 분자/분모의 값을 그대로 유지할 수 있다.
  * 4/2 처럼 분모와 분자 간에 약분이 가능한 형태일 경우 2 로 약분된다.
  * 분수의 분모/분자에는 무조건 정수만 올 수 있다.
  * **나눗셈 연산 시 주의사항**
    * `(/ 1 3)` : 분자/분모가 모두 정수일 경우 분수형태의 자료형을 반환한다.
    * `(/ 1 3.0)` : 분자/분모 중 어떤 값이라도 실수일 경우, 실수형을 반환한다.
* `키워드(keyword)`는 `콜론(:)`으로 시작하는 식별자이다.
  * `맵(map)`에서 어떤 값을 키로 접근할 때 많이 쓰인다.
* `문자 리터럴`을 나타내고자 할 경우, 알파벳 앞에 `역슬래시(\)` 를 붙여서 표현한다.
  * 예를 들어, 문자 j를 나타내고자 할 경우 `\j`로 표기한다.
  * 문자열로 나타낼 때보다 부하가 줄어들기 때문에 편리함
* `nil`은 클로저에서 값이 없음을 나타낸다.

## 컬렉션

* 클로저에서 데이터를 담을 수 있는 컬렉션은 다음과 같다.
  * `리스트(list)`, `벡터(vector)`, `맵(map)`, `집합(set)`
* 모든 컬렉션은 `불변(immutable)`이고 `존속적(persistent)`이다.
  * `cons`로 컬렉션에 새로운 요소를 추가하면, 그 요소가 추가된 새로운 버전의 컬렉션이 반환된다. 따라서 컬렉션의 값은 불변이다.
  * `구조 공유(structual sharing)` 기법으로 컬렉션의 신규 버전이 효율적으로 만들어진다.

### 리스트

* `링크드리스트(linked list)`로 생각하면 이해하기 편하다.
* 리스트를 나타내고자 할 때, 괄호(소괄호) 안에 여러 값들을 구분자 없이 나열한 다음, 여는 괄호 앞에 인용 부호를 붙이면 된다.
  * 예시 : `'(1 2 "jam" :marmalade-jar)`
  * 요소들 사이에 쉼표가 있어도 상관없다.
  * *괄호를 그대로 둘 경우, 함수로 평가되기 때문에 리스트를 나타내고자 할 때, 인용부호를 괄호앞에 붙이는 표기가 필요함.*
* 리스트의 첫 요소는 `first` 함수를 이용하고, 첫 요소를 제외한 나머지는 `rest` 함수를 이용해서 접근한다.
  * `rest`를 이용해서 리스트의 마지막에 다다르면 `nil`을 만나게 되는데, 이는 리스트의 끝을 의미한다.
    * 이는 재귀함수를 작성할 때, 종료 조건으로써 매우 중요한 역할을 한다.
* `cons` 함수를 이용하여 리스트의 head 에 원소를 삽입할 수 있다.
  * `(cons 5 '())` : `'()`는 `nil`과 동치이다.
  * `;=> (5)`
* 인용부호를 이용하지 않더라도, `list`를 이용하여 리스트를 생성할 수 있다.
  * 예시 : `(list 1 2 3 4 5)`

### 벡터

* 컬렉션 내부의 임의의 원소에 인덱스를 이용하여 접근할 수 있다.
* `벡터`는 대괄호로 둘러싸서 표기한다. `[1 2 3 4 5]`
* `nth` 함수를 이용하여 해당 인덱스에 있는 벡터의 요소에 접근할 수 있다.
  * 예시 : `(nth [1 2 3 4] 0)`
  * 리스트에서도 `nth`를 이용하여 접근할 수 있지만, 링크드리스트로 구현되어 있기 때문에 앞에서부터 순차적으로 접근하는 반면, 벡터는 전체를 거치지 않고 해당 인덱스로 직접적인 접근이 가능하다. 
  * 따라서, `nth`를 이용하고자 할 때, 벡터를 이용하는 것이 좋다.
* `count` 함수는 컬렉션의 크기를 반환한다.
* `conj` 함수는 컬렉션에 하나 이상의 요소를 추가한다.
  * 하나 이상의 요소를 추가하되, 그 컬렉션의 데이터 구조에 따라 가장 효율적인 방식으로 추가한다.
  * `벡터` : 컬렉션의 맨 뒤에 요소를 추가한다.
  * `리스트` : 컬렉션의 맨 앞에 요소를 추가한다.

### 집합

* 요소의 중복이 없는 컬렉션을 만들 때 사용한다.
* `집합(set)`은 `#{}`로 둘러싸서 나타낸다. 
* 집합이기 때문에 `합집합(union)`, `차집합(difference)`, `교집합(intersection)` 같은 집합 연산이 가능하다.
* `set` 함수를 이용해 다른 종류의 컬렉션을 집합으로 바꿀 수 있다.
  * `벡터`에 사용할 경우, 중복된 요소를 제거할 때 쓰인다.
  * `맵`에 사용할 경우, 키-값 쌍을 벡터로 변환 후 집합의 요소가 되도록 한다.
* `get` 함수를 사용하여 집합에서 요소를 가져올 수 있다.
  * 예시 : `(get #{:rabbit :door :watch} :rabbit)`
  * 찾으려는 요소가 키워드일 경우, 그 키워드로 직접 접근할 수 있다.
  * 요소가 집합에 없을 경우 `nil`을 반환한다.
* 키워드를 사용해서 직접 요소를 가져올 수도 있다.
  * 예시 : `(:rabbit #{:rabbit :door :watch})`
* 집합 자체를 함수로 사용해서 `get` 함수처럼 사용할 수 있다.
  * 예시 : `(#{:rabbit :door :watch} :rabbit)`

#### 집합의 연산
* `clojure.set/union` : 합집합
* `clojure.set/difference` : 차집합
* `clojure.set/intersection` : 교집합
* `contains?` : 집합에 요소가 있는지 확인할 때 쓰인다.
  * 예시 : `(contains? #{:rabbit :door :watch} :rabbit)`
* `disj` : 집합에서 요소를 제거할 때 사용한다. 
  * 예시 : `(disj #{:rabbit :door} :door)`

### 맵

* 키(key)-값(value) 쌍으로 구조화된 데이터를 저장하는 데 사용되는 컬렉션이다.
* `맵(map)`은 중괄호로 싸서 나타낸다.
  * 가독성을 위해서 쉼표를 이용하여 나타낼 수도 있다. `{:jam "strawberry", :jam "blackberry"}`
* `get` 함수로 맵에서 값을 가져올 수 있다.
  * 예시 : `(get {:jam1 "s" :jam2 "b"} :jam2)`
  * 키가 없을 경우, 디폴트 값을 줄 수도 있다. `(get {:jam1 "a", :jam2 "b"} :jam3 "c")` 
  * **맵의 키가 키워드일 경우, `get`을 쓰지 않더라도 키 자체를 함수로 사용해서 값을 가져올 수 있다.**
    * 예시 : `(:jam1 {:jam1 "a", :jam2 "b"})`

#### 맵의 연산
* `keys` 함수는 맵의 키로 이루어진 리스트를 반환한다.
* `vals` 함수는 맵의 값으로 이루어진 리스트를 반환한다.
* `assoc` 함수는 맵에 새로운 키-값 쌍을 결합한다.
* `dissoc` 함수는 맵과 키를 인수로 받아, 해당 키-값 쌍이 제거된 새로운 맵을 반환한다.
* `merge` 함수는 여러 맵의 키-값 쌍을 합치는 데 사용한다.


## 심볼과 바인딩

* 클로저에서 심볼은 값을 가리키며, 심볼이 평가되면 그 심볼이 가리키는 값을 반환한다.
  * 일반적으로 값을 위한 `var`를 만들어, 심볼에 바인딩하는 경우가 많다. 
* `def`는 값에 이름을 줘서 나중에 다른 곳에서 그 값을 참조할 수 있게 한다.(전역 바인딩)
  * `def`는 심볼에 값을 직접 바인딩하지 않고 `var`를 통해서 한다.
    * 이 때, `var`는 프로그램이 수행되면서 그 값이 변하지 않는다.
* `let` 으로 지역 바인딩이 가능하다.
  * `let` 바인딩은 벡터 안에 심볼과 값의 쌍들로 구성된다.
  * `let` 안에서 바인딩한 심볼은 `let` 안에서만 유효하기 때문에, `let` 바깥에서 참조할 수 없다.

## 함수

* `defn` 을 이용해서 함수를 정의한다. 함수를 위한 `var`를 생성한다.
  * `함수의 이름, 주석(생략 가능), 함수 인수들의 벡터, 함수 본문을 인수로 받는다.
* 함수를 호출하려면 함수를 괄호로 둘러싸서 사용하면 된다.

### 익명 함수(Anonymous function)

* 이름을 붙이지 않고 간단하게 사용하고 싶을 때 쓰인다.
* `fn` 연산자로 만들 수 있으며, 인수들의 벡터와 함수 본문을 인수로 받는다.
* 익명 함수를 만드는 단축형도 있다.
  * 괄호 앞에 `#`를 붙이면 된다.
    * 예시 : `(#(str "Off we go" "1"))`
  * 인수가 있다면 퍼센트 기호(%)로 나타낼 수 있다.
    * 인수가 하나인 경우, `(#(str "Off we go" "!" " - " %) "again")`
    * 인수가 여러개인 경우, `(#(str "Off we go" "!" " - " %1 %2) "again" "?")`

## 이름공간(Namespace)

* `var`에 대한 접근을 조직하고 제어하는 방법이다.
* `def`와 `defn`으로 `var`를 만들 때 user라는 REPL의 디폴트 이름공간에서 `var`를 생성한다.
  * 디폴트 이름공간에서 정의된 `fav-food`라는 `var`의 완전한 이름은 `user/fav-food`이다.
* `ns` 를 사용하면 이름공간을 새로 만들고 현재 이름공간을 다른 이름공간으로 전환할 수 있다.
  * REPL에서 현재 이름공간을 확인하고자 할 때 `*ns*`를 활용하자.
* 다른 이름공간에서 값을 참조하고자 할 때, 완전한 이름을 사용해야 한다.
  * 같은 이름공간에서 생성된 `var`는 완전한 이름을 사용하지 않아도 참조가능하다.

### 라이브러리 사용하기

* 클로저의 라이브러리들은 이름공간과 그 이름공간의 심볼들로 구성된다. 
* `require`를 사용해서 자신의 이름공간에서 라이브러리를 사용할 수 있는 세 가지 방법이 있다.
  1. 이름공간을 인수로 받아 `require`를 사용한다.
      * 예시 : `(require 'clojure.set)` 
  2. `:as`를 사용해서 `require`의 `별칭(alias)` 기능을 이용한다.
      * **대부분의 클로져 코드에서 사용한다.**
      * 예시 : `(require '[alice.favfoods :as af])`
      * `require`를 직접 사용할 수도 있지만, 일반적으로 `ns` 안에서 키워드와 벡터의 형태로 사용한다.
        * 예시 : `(ns wonderland (:require [alice.favfoods :as af]))` <- `:require` 를 키워드로써 활용 
  3. `require`를 이름공간, `:refer`, `:all` 옵션과 함께 사용한다.
      * 이름공간의 모든 심볼이 로딩되고 현재의 이름공간에서 심볼 이름만으로 직접 접근이 가능하다.
        * 이름 충돌이 발생할 우려가 있다.
      * `use` 함수를 이용할 수도 있다.
      * 예시 
      ```clojure
      (ns wonderland
        (:require [alice.favfoods :refer :all]
                  [rabbit.favfoods :refer :all]))
      ```
* 테스트코드를 작성할 경우, 테스트하려는 이름공간과 `clojure.test`의 함수들을 직접 사용한다.


## 자잘한 것들

* `defn`과 `(def (fn))`은 사실상 같은 역할을 한다.
  * `fn`은 함수 자체를 반환하여 인자를 받을 수 있는 반면, `defn`은 사실상 `def`이기 때문에, `var`를 생성하는 역할을 한다.
```clojure
user=> (defn th [l n]
  #_=>   (if (= n 0)
  #_=>     (first l)
  #_=>     (th (rest l) (- n 1))
  #_=>   ))
#'user/th
user=> (th [1, 2, 3] 0)
1
user=> (th [1, 2, 3] 2)
3
user=> (fn [l n]
  #_=>   (if (= n 0)
  #_=>     (first l)
  #_=>     (recur (rest l) (- n 1))
  #_=>   ))
#object[user$eval1299$fn__1300 0x41d75ac3 "user$eval1299$fn__1300@41d75ac3"]
```